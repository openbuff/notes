# 状态模式
允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类
## 结构
1. Context上下文环境角色，负责状态的切换，持有一个内部状态对象，代表着环境当前所处的状态
2. State抽象状态角色, 可以是一个接口或者抽象类，定义了所有具体状态的共同接口或者是说动作行为，任何具体状态都要实现这些接口
3. ConcreteState具体状态角色，处理来自Context的请求，每一个ConcreteState都提供了它自己对请求的实现，它要完成两个任务，一个是本状态下的行为管理，另一个是如何过渡到下一个状态。并且持有环境角色以实现状态的切换
## 优点
* 结构清晰，避免了过多的switch…case或if…else语句的使用
* 很好的体现了开闭原则和单一职责原则，想要增加状态就增加子类，想要修改状态就修改子类即可
* 封装性非常好，状态变化放置到了类的内部来实现，外部调用不需要知道类内部如何实现状态和行为的变换
## 缺点
* 子类会太多，也即类膨胀
## 使用场景
* 行为随状态改变而改变的场景
* 条件、分支语句的代替者
## 注意事项
* 在行为受状态约束的时候使用状态模式，而且状态不超过 5 个
## 代码示例
```java
public interface State {
   public void doAction(Context context);
}

public class StartState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in start state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Start State";
   }
}

public class StopState implements State {
 
   public void doAction(Context context) {
      System.out.println("Player is in stop state");
      context.setState(this); 
   }
 
   public String toString(){
      return "Stop State";
   }
}

public class Context {
   private State state;
 
   public Context(){
      state = null;
   }
 
   public void setState(State state){
      this.state = state;     
   }
 
   public State getState(){
      return state;
   }
}

public class StatePatternDemo {
   public static void main(String[] args) {
      Context context = new Context();
 
      StartState startState = new StartState();
      startState.doAction(context);
 
      System.out.println(context.getState().toString());
 
      StopState stopState = new StopState();
      stopState.doAction(context);
 
      System.out.println(context.getState().toString());
   }
}

/*
Player is in start state
Start State
Player is in stop state
Stop State
*/
```