# 策略模式
定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换
## 结构
1. Context上下文，也叫Context封装角色，起承上启下的作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化
2. 抽象策略角色，是对策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性
3. 具体策略角色，用于实现抽象策略中的操作，即实现具体的算法
## 优点
* 算法可以自由切换
* 避免使用多重条件判断（如果不用策略模式我们可能会使用多重条件语句，不利于维护）
* 扩展性良好，增加一个策略只需实现接口即可
## 缺点
* 策略类数量会增多，每个策略都是一个类，复用的可能性很小
* 所有的策略类都需要对外暴露
## 使用场景
* 如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为
* 一个系统需要动态地在几种算法中选择一种
* 如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现
## 注意事项
* 如果一个系统的策略多于四个，就需要考虑使用混合模式来解决策略类膨胀的问题
## 代码示例
```java
//抽象策略角色
public interface Strategy {
   public int doOperation(int num1, int num2);
}
//具体策略模式
public class OperationAdd implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 + num2;
   }
}
public class OperationSubtract implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 - num2;
   }
}
public class OperationMultiply implements Strategy{
   @Override
   public int doOperation(int num1, int num2) {
      return num1 * num2;
   }
}
//Context
public class Context {
   private Strategy strategy;
 
   public Context(Strategy strategy){
      this.strategy = strategy;
   }
 
   public int executeStrategy(int num1, int num2){
      return strategy.doOperation(num1, num2);
   }
}


public class StrategyPatternDemo {
   public static void main(String[] args) {
      Context context = new Context(new OperationAdd());    
      System.out.println("10 + 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationSubtract());      
      System.out.println("10 - 5 = " + context.executeStrategy(10, 5));
 
      context = new Context(new OperationMultiply());    
      System.out.println("10 * 5 = " + context.executeStrategy(10, 5));
   }
}
```